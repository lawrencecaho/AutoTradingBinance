# 密钥管理与安全通信指南

本文档提供了密钥管理与安全通信的详细说明，帮助开发者理解和维护系统安全。

## 密钥类型和用途

系统使用多种密钥来保证安全通信：

1. **RSA 密钥对**：用于非对称加密，保护数据传输
   - 私钥：保存在服务器，用于解密前端发送的数据
   - 公钥：分发给前端，用于加密发送到服务器的数据

2. **API Secret Key**：用于对请求进行签名，防止篡改
   - 保存在服务器，用于验证请求签名
   - 前端使用特殊的"frontend"固定签名值

3. **JWT Secret**：用于生成和验证JWT令牌
   - 保存在服务器，确保令牌不被伪造

4. **TOTP Secret**：用于双因素认证
   - 每个用户唯一，保存在数据库中
   - 用于生成和验证一次性密码

## 密钥存储

### 服务器端

1. **数据库存储**
   - RSA密钥对存储在`global_options`表中
   - TOTP密钥存储在`userbasic`表中

2. **文件存储**
   - RSA密钥对备份在`myfastapi/Security/`目录
   - 格式为PEM文件

3. **环境变量**
   - JWT_SECRET
   - API_SECRET_KEY
   - DATABASE_URL

### 客户端

1. **浏览器Storage**
   - JWT令牌存储在localStorage中
   - 用户信息存储在localStorage中
   - 公钥临时存储在内存中

## 密钥轮换

系统实现了自动密钥轮换机制：

1. **RSA密钥对**
   - 每30天自动轮换一次
   - 轮换触发条件：检查数据库中的`fixed_time`字段
   - 轮换过程：生成新密钥对，更新数据库和本地文件

2. **API密钥和JWT密钥**
   - 目前需要手动更新
   - 建议定期更新这些密钥

## 安全通信流程

1. **初始化**
   - 前端请求`/security-info`获取服务器公钥
   - 服务器返回公钥和安全配置信息

2. **请求加密**
   - 前端使用公钥加密请求数据
   - 添加时间戳和固定签名值"frontend"

3. **服务器验证**
   - 验证请求头中的安全信息（API Key, 时间戳, 签名）
   - 使用私钥解密请求数据
   - 处理业务逻辑

4. **响应加密**
   - 服务器使用客户端公钥加密响应数据
   - 签名响应数据确保完整性
   - 前端使用客户端私钥解密响应

## 前端集成

### 设置公钥

```typescript
// 初始化时获取公钥
await secureApi.initialize();
```

### 发送加密请求

```typescript
// 发送加密请求
const response = await secureApi.request<ResponseType>(
  apiEndpoints.someEndpoint, 
  requestData
);
```

### 响应解密

```typescript
// 在secureApi.ts中：
// 初始化过程中生成客户端密钥对
clientKeys = await generateClientKeyPair();

// 发送加密请求并自动解密响应
const response = await sendSecureRequest<ResponseType>(endpoint, data);
// response 已经是解密后的数据
```

## 双向加密

系统现在支持完整的双向加密通信：

1. **客户端密钥对**
   - 浏览器使用Web Crypto API生成RSA密钥对
   - 客户端公钥发送给服务器
   - 客户端私钥保留在浏览器内存中，用于解密响应

2. **加密流程**
   - 前端->后端：使用服务器公钥加密
   - 后端->前端：使用客户端公钥加密

3. **密钥注册**
   - 前端在初始化时自动注册客户端公钥
   - 服务器维护客户端ID与公钥的映射
   
4. **安全优势**
   - 完整的端到端加密
   - 防止中间人攻击
   - 确保数据完整性和保密性

## 安全性注意事项

1. **密钥保护**
   - 私钥必须严格保密
   - 不要在代码仓库中存储密钥
   - 使用环境变量或加密的配置文件

2. **签名验证**
   - 前端使用固定签名值"frontend"，后端特殊处理
   - 移动端等其他客户端应实现完整的签名机制

3. **HTTPS**
   - 始终使用HTTPS进行通信
   - 即使数据已加密，也需要传输层安全

4. **时间同步**
   - 确保服务器和客户端时间同步
   - 时间戳验证依赖于时间一致性

## 故障排除

### 签名验证失败

检查：
- 请求头中是否包含所有必要字段
- 时间戳是否在有效范围内（当前时间±60秒）
- 签名值是否正确（前端应为"frontend"）

### 解密失败

检查：
- 公钥格式是否正确
- 加密算法参数是否一致
- 数据是否正确Base64编码

## 进一步增强安全性

1. 实现完整的客户端签名验证
2. 添加请求限流机制
3. 实现IP白名单
4. 添加异常行为检测
5. 定期安全审计
